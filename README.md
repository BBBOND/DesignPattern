# 设计模式（DesignPattern）
- 三大分类
    - 创建型模式，共五种
        - 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
    - 结构型模式，共七种
        - 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
    - 行为型模式，共十一种
        - 策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
- 六大原则
    - 开闭原则（Open Close Principle）
        - **对扩展开放，对修改关闭。**在程序需要进行拓展的时候，不能去修改原有的代码，而是去实现一个热插拔的效果。为了使程序的扩展性好，易于维护和升级。需要使用接口和抽象类。
    - 里氏代换原则（Liskov Substitution Principle）
        - **任何基类可以出现的地方，子类一定可以出现。**
    - 依赖倒转原则（Dependence Inversion Principle）
        - **针对接口编程，依赖于抽象而不依赖于具体。**
    - 接口隔离原则（Interface Segregation Principle）
        - **使用多个隔离的接口，比使用单个接口要好。**
    - 迪米特法则（最少知道原则）（Demeter Principle）
        - **一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。**
    - 合成复用原则（Composite Reuse Principle）
        - **尽量使用合成/聚合的方式，而不是使用继承。**
    
## 创建型模式
### 工厂模式Factory
- 概念
    - 使用工厂方法代替new操作。
- 分类
    - **简单工厂模式Static Factory**
        - 概念
            - 简单工厂模式又称静态工厂模式。定义一个用于创建对象的接口。
        - 组成
            - 工厂类角色：模式的核心，含有一定的商业逻辑和判断逻辑。
            - 抽象产品角色：是具体产品继承的父类或者实现的接口。
            - 具体产品角色：工厂类所创建的对象。
        - 缺点
            - 添加新的创建对象时，需要修改工厂类，违反开闭原则。
    - **工厂方法模式Factory Method**
        - 概念
            - 去掉简单工厂模式的静态属性，使之可继承，压力由不同的工厂子类分担。
        - 组成
            - 抽象工厂角色：模式的核心，与程序无关。
            - 具体工厂角色：含有和具体业务逻辑相关的代码。由应用程序调用创建对应的具体产品的对象。
            - 抽象产品角色：是具体产品继承的父类或者实现的接口。
            - 具体产品角色：工厂类所创建的对象。
        - 优点
            - 分担对象承受的压力
            - 结构变得灵活
            - 符合开闭原则
            
### 抽象工厂模式Abstract Factory
- 概念
    - 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。
- 组成
    - 抽象工厂角色：模式的核心，与程序无关。
    - 具体工厂角色：含有和具体业务逻辑相关的代码。由应用程序调用创建对应的具体产品的对象。
    - 抽象产品角色：是具体产品继承的父类或者实现的接口。
    - 具体产品角色：工厂类所创建的对象。
- 应用场景
    - 系统中有多个产品族，而系统一次只可能消费其中一族产品。
    - 同属于同一个产品族的产品一起使用。

### 单例模式singleton
- 概念
    - 通过单例模式可以保证系统中一个类只有一个实例。
- 分类
    - 饿汉模式
    - 懒汉模式
    - 双重锁模式
- 优点
    - 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
    - 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。
    - 有些类控制着流程，如果该类可以创建多个的话，系统会完全混乱。



## 策略模式Strategy（对象行为型）
- 概念
    - 策略模式把对象本身和运算规则区分开来，这个设计模式本身的核心思想是面向对象编程的多形性的思想。
    - 策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
- 组成
    - 抽象策略角色：策略类，通常由一个接口或者抽象类实现。
    - 具体策略角色：包装了相关的算法和行为，一般是对抽象策略角色的实现。
    - 环境角色：持有一个策略类的引用，最终给客户端调用。
- 应用场景
    - 多个类只区别在表现行为不同，可以使用策略（Strategy）模式，在运行时**动态选择**具体要执行的行为。
    - 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。
    - 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。

## 代理模式Proxy（结构型）
- 概念
    - 为其他对象提供一种代理，并以控制对这个对象的访问。
    - 对象实现同一个接口,先访问代理类再访问真正要访问的对象。
- 组成
    - 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。
    - 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
    - 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
- 应用场景
    - 就是采用一个代理类调用原有的方法，且对产生的结果进行控制。

## 单例模式Singleton（创建型）
- 概念
    - 一个类有且仅有一个实例，并且自行实例化向整个系统提供。
- 应用场景
    - 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
    - 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

